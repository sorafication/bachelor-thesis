\subsection{Implementierung API und Datenbank}
Der erste benötigte Dienst für die Webanwendung ist die GraphQL API.
Mit \spverb+amplify add api+ startet der Konfigurationsassistent.
Da die Authentifizierung mit Cognito erst zu einem späteren Zeitpunkt hinzugefügt wird, erfolgt sie solange mittels API Key.
Nach Bestätigung des letzten Schrittes öffnet sich die Datei \verb+schema.graphql+, die das Schema der API darstellt.
In dieser Datei werden alle benötigten Objekttypen erstellt.
\clearpage
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{flashwhite} ]
Please select from one of the below mentioned services:(*@ \textrm{GraphQL} @*)
Provide API name:(*@ \textrm{amplify-kumo-api} @*)
Choose the default authorization type for the API:(*@ \textrm{API key} @*)
Enter a description for the API key:(*@ \textrm{My-Dev-ApiKey} @*)
After how many days from now the API key should expire (1-365):(*@ \textrm{7} @*)
Do you want to configure advanced settings for the GraphQL API:(*@ \textrm{No} @*)
Do you have an annotated GraphQL schema?(*@ \textrm{No} @*)
Do you want a guided schema creation?(*@ \textrm{Yes} @*)
What best describes your project:
Single object with fields (e.g., Todo with ID, name, description)
Do you want to edit the schema now?(*@ \textrm{Yes} @*)
\end{lstlisting}

Im Rahmen der Bachelorarbeit wird nur ein Objekttyp mit dem Namen Account benötigt.
Es werden weiterhin alle verfügbaren Felder angegeben.
Werden in Zukunft neue Felder oder weitere Typen benötigt, kann die Datei \verb+schema.graphql+ jederzeit angepasst werden.
\\
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{flashwhite} ]
type Account @model {
  id: ID!
  accountid: String!
  name: String!
  email: String!
  num: Int!
  status: String!
}

\end{lstlisting}

Alle angegeben Felder müssen im späteren Verlauf von der Lambda-Funktion abgerufen und gespeichert werden.
Mit dem Befehl \verb+amplify push+ wird die API in der Cloud bereitgestellt.
Im folgenden Dialog besteht die Möglichkeit alle möglichen Mutationen und Queries generieren zu lassen.
Wie bereits im Abschnitt \textit{\ref{GraphQL} \nameref{GraphQL}} erwähnt, wäre es bei GraphQL normalerweise üblich die Query-Typen etc. manuell zu erzeugen.
AppSync übernimmt hier also wie versprochen einen großen Teil der Arbeit.
\\
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{flashwhite} ]

# You will be walked through the following questions for GraphQL code generation

Do you want to generate code for your newly created GraphQL API? (*@ \textrm{Y} @*)
Choose the code generation language target:(*@ \textrm{javascript} @*)

Do you want to generate/update all possible GraphQL operations -
queries, mutations and subscriptions? (*@ \textrm{Y} @*)

\end{lstlisting}


Sobald der Prozess fertig gestellt ist, sind die Dienste AWS AppSync und DynamoDB konfiguriert.
Dank DynamoDB-Resolver wurde eine entsprechende DynamoDB-Tabelle angelegt und konfiguriert.
In der Webkonsole von AWS kann überprüft werden, ob der Vorgang erfolgreich war.
Die Ansicht von AppSync zeigt im Menüpunkt \grqq Data Sources\grqq{}, dass eine DynamoDB-Tabelle passend zum GraphQL Objekttyp erstellt wurde.
Der Name der Tabelle wurde nach dem GraphQL Objekttyp gewählt.
Nun ist es möglich per API auf die Datenbank zuzugreifen und Daten abzufragen.
Die jeweilige Abfrage findet im Abschnitt \textit{\ref{ReactFrontend} \nameref{ReactFrontend}} statt.
Bevor das Frontend jedoch Anfragen an die Datenbank ausführen kann, muss Lambda konfiguriert werden, sodass Daten gespeichert werden.
\\
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{50-Implementierung/AppSync-DynamoDB.png}
    \caption{Erfolg der GraphQL API Erstellung überprüfen}
    \label{fig:meine-grafik}
\end{figure}





\subsection{Implementierung Backend-Logik}
\label{ImpLambda}
Die gesamte Backend-Logik wird durch Lambda realisiert.
Mit dem Befehl \spverb+amplify add function+ startet Amplify den Prozess.
Dabei ist es im Rahmen der Bachelorarbeit ausreichend, wenn die Lambda-Funktion in regelmäßigen Abständen ausgeführt wird.
Weitere Auslöser können in Zukunft ergänzt werden.
In der Regel werden neue AWS Accounts in Abständen von 2-3 Wochen erstellt.
\\
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{flashwhite} ]
[143302S0:amplify-kumo] master # amplify add function

Using service: Lambda, provided by: awscloudformation
Provide a friendly name for your resource to be used as
a label for this category in the project: (*@ \textrm{getallaccounts} @*)
Provide the AWS Lambda function name: (*@ \textrm{getallaccounts} @*)
Choose the function runtime that you want to use: (*@ \textrm{NodeJS} @*)
Choose the function template that you want to use:(*@ \textrm{Hello World} @*)
Do you want to access other resources created in this
project from your Lambda function? (*@ \textrm{Yes} @*)
Select the category:(*@ \textrm{storage} @*)
Do you want to invoke this function on a recurring schedule? (*@ \textrm{Yes} @*)
At which interval should the function be invoked: (*@ \textrm{Daily} @*)
Select the start time (use arrow keys):(*@ \textrm{06:35 PM} @*)

Successfully added resource getallaccounts locally.
\end{lstlisting}

\clearpage
Nachdem Amplify die Lambda-Funktion erstellt hat, kann diese direkt bearbeitet werden.
Der vollständige Code befindet sich im Anhang (Siehe Anhang \ref{lst:LambdaCode} \nameref{lst:LambdaCode}).
Im Kern besteht die Lambda-Funktion aus vier Funktionen.
\\

\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{flashwhite} ]
getCallerIdentity()
getCrossAccountCredentials()
listAllAccounts()
writeAllDynamoDBItems()
\end{lstlisting}


Die Funktionen \spverb+getCallerIdentity()+ und \spverb+getCrossAccountCredentials()+ dienen den Zweck temporäre Zugriff auf den Account \spverb+Cbc-Master+ zu erhalten.
\spverb+listAllAccounts()+ liest anschließend alle Daten und \spverb+writeAllDynamoDBItems()+ schreibt diese in die DynamoDB-Tabelle.
Eine Schwierigkeit war es, eine Identität im \verb+Cbc-Master+ anzunehmen, eine weitere die korrekte Abarbeitung der Funktion sicherzustellen.
In den folgenden Abschnitten werden diese beiden Hürden genauer erläutert.

\subsubsection{Accountübergreifender Zugriff}
\label{AccountübergreifenderZugriff}
Die Lambda-Funktion befindet sich im AWS Account \verb+Cbc-Clouds-Sandbox+ und muss auf den Account \verb+Cbc-Master+ zugreifen.
Im Account \verb+Cbc-Master+ wird eine IAM-Rolle benötigt, die der Lambda-Funktion Zugriff gewährt.
Der Abschnitt \ref{Accountstruktur} \nameref{Accountstruktur} beschreibt den Aufbau aller Accounts der Mediengruppe RTL.
Mit IAM-Rollen können Benutzeraccounts oder AWS-Dienste temporäre Anmeldeinformationen erhalten, die Accountübergreifend funktionieren.
Dabei wird die Identität der IAM-Rolle übernommen.
Dementsprechend sind alle Operationen erlaubt, die der IAM-Rolle zugewiesen worden sind.
Damit die Lambda-Funktion also in dem Account \verb+Cbc-Master+ auf AWS Organizations zugreifen kann, benötigt die IAM-Rolle mindestens Lesezugriff auf den Dienst AWS Organizations.
AWS bietet hierfür die Berechtigung \verb+AWSOrganizationsReadOnlyAccess+.

Außerdem muss eine Vertrauensstellung hergestellt werden.
Das folgende Bild zeigt die konfigurierte Vertrauensstellung zwischen Lambda-Funktion im \verb+Cbc-Clouds-Sandbox+ und der IAM-Rolle im \verb+Cbc-Master+ Account.
Im unteren Linken Bereich bei \glqq Trusted Identities\grqq{} ist die Identität der Lambda-Funktion aus dem Account \verb+Cbc-Clouds-Sandbox+ zu sehen.
163962199350 ist die dazugehörige AccountID.
Die IAM-Rolle hat den Namen \grqq amplify-kumo-access-role\grqq{} und besitzt einen eindeutigen Ressourcennamen (ARN).
Dieser ARN muss in der Lambda-Funktion angegeben werden. Nur so weiß weiß die Funktion welche Identität sie übernehmen soll.

\clearpage

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{50-Implementierung/IAM-Rolle.png}
    \caption{Vertrauensstellung zwischen beiden Accounts}
    \label{fig:meine-grafik}
\end{figure}


Um diesen Zugriff zu programmieren, dienen die Funktionen \verb+getCallerIdentity()+ und \verb+getCrossAccountCredentials()+.
\verb+getCallerIdentity()+ ist eine Hilfsfunktion und gibt die aktuelle Identität zurück.
So ist es leichter zu überprüfen, ob die Rolle \grqq amplify-kumo-access-role\grqq{} im \verb+Cbc-Master+ Account erfolgreich angenommen wurde.
Das eigentliche Übernehmen der IAM-Rolle erledigt \verb+getCrossAccountCredentials()+.
Es wird ein neues AWS Service-Objekt für den Dienst AWS Organizations erstellt und mithilfe der Funktion \verb+sts.assumeRole()+ ein temporärer Zugriff im Master-Account erstellt.

Ein Service-Objekt wird benötigt, um auf Service-Funktionen zugreifen zu können.
Die meisten AWS-Dienste bieten mindestens ein passendes Service-Objekt an.
In der Lambda-Funktion muss dementsprechend ein Service-Objekt für die Dienste AWS Organizations, DynamoDB und für die Hilfsfunktion AWS STS \footnote{STS steht für Security Token Service und ermöglicht die Bereitstellung von temporären Anmeldeinformationen.} erstellt werden.
\cite[]{ServiceObject}

Für DynamoDB reicht etwa folgender Befehl aus um eine passendes Service-Objekt zu erstellen.
Die Lambda-Funktion und die DynamoDB-Tabelle befinden sich im selben Account.
Auch besitzt die Lambda-Funktion bereits alle nötigen Berechtigungen, da diese durch Amplify gesetzt wurden.
\\
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{flashwhite} ]
var docClient = new AWS.DynamoDB.DocumentClient
\end{lstlisting}


Für AWS Organizations müssen bei der Erstellung des Service-Objekts zusätzlich die temporären Anmeldeinformation mitgegeben werden, da sich der Dienst in einem anderen Account befindet.
Außerdem muss die Region geändert werden.
AWS Organizations ist ein Dienst, der nur in der Region \verb+us-east-1+ betrieben wird.
Für diesen Vorgang wird die Funktion \verb+getCrossAccountCredentials()+ benötigt.
Im ersten Schritt werden temporäre Anmeldeinformation abgerufen und anschließend dem Service-Objekt übergeben.

\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lightgray}, caption={Neues ServiceObject mit einer anderen Identität} ]
var accessparams = await getCrossAccountCredentials();

const cbc_master_orgs = new AWS.Organizations({
    credentials: accessparams,
    region: 'us-east-1'
  });
\end{lstlisting}


Im Anschluss ist es möglich die Funktion \verb+listAllAccounts()+ mit einer anderen Identität auszuführen.
Dafür muss das neu erstellte ServiceObjekt übergeben werden.

\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lightgray}, caption={Funktionsaufruf mit anderer Identität} ]
    listAllAccounts(cbc_master_orgs)
\end{lstlisting}

\subsubsection{Asynchrone Verarbeitung mit NodeJS}

Alle vier Funktionen werden im Handler der Funktion nacheinander ausgeführt.
Neben den unterschiedlichen Identitäten war die Sicherstellung der asynchronen Abarbeitung ein wichtiger Aspekt bei der Programmierung.
Alle Funktionen durften nicht gleichzeitig ausgeführt werden, da sie voneinander abhängig waren.
Damit die Funktion \verb+listAllAccounts()+ erfolgreich war, musste zuvor Identität des Master-Accounts angenommen werden.
Zudem muss die Funktion \verb+writeAllDynamoDBItems()+ auf die Fertigstellung von \verb+listAllAccounts()+ warten, da sie sonst keine Daten zum speichern hat.

NodeJS arbeitet Single-Threaded.
Das bedeutet, dass zu einem Zeitpunkt immer nur genau eine Aufgabe erledigt werden kann.
Aufgrund der Abhängigkeit der Funktionen muss eine asynchrone Abarbeitung stattfinden.
Zur Option stehen dazu Callbacks, Promises oder eine Implementierung mit async/await.
Ein Callback ist eine Funktion die an eine weitere Funktion weitergegeben wird.
So wird sichergestellt, dass die zweite Funktion erst aufgerufen wird, sobald die Erste beendet ist.
Das Problem von Callbacks ist die große Unübersichtlichkeit bei mehreren Funktionen
Das immer tiefere verschachteln von Funktionsaufrufen wird auch als \glqq Callback-Hölle\grqq{} bezeichnet.
Promises ermöglichen die selbe Funktionalität wie Callbacks, nur ohne die Verschachtelung.
\glqq Ein Promise ist ein Objekt, das die finale Beendigung einer asynchronen Operation repräsentiert.
Je nachdem, ob die Operation erfolgreich oder fehlerhaft beendet wurde, wird das Promise entsprechend gekennzeichnet. \grqq{} \cite[]{Promises}
Mit der Option \verb+.then()+ kann sichergestellt werden, dass die Operation beendet sein muss bevor der nächste Codeblock beginnt.
Die letzte Möglichkeit ist die Verwendung von \verb+async/await+, welche auf Promises basiert jedoch eine verständlichere Syntax ermöglicht.
Eine Funktion kann mit \verb+async+ als Asynchron deklariert werden.
Innerhalb einer asynchronen Funktion kann mit dem Operator \verb+await+ auf die Erfüllung des Promises gewartet werden.
Es ist auch möglich den Operator \verb+await+ in einer Funktion mehrmals zu verwenden.

Die Lambda-Funktion nutzt Promises und \verb+async/await+ zu einem großen Teil aus um die Funktionalität gewährleisten zu können.
Der Event Handler wird als Asnychron deklariert und innerhalb des Handlers werden alle oben genannten Funktion nacheinander aufgerufen.
Die genaue Verwendung der asnychronen Abläufe befindet sich im Anhang.

\subsubsection{Verifizierung Lambda-Funktion}

Nachdem die Lambda-Funktion erfolgreich erstellt wurde, ist es erforderlich das Ergebnis zu überprüfen.
Nur wenn die Funktion erfolgreich Daten in die DynamoDB-Tabelle gespeichert hat, kann der nächste Dienst integriert werden.
Zur einfachen Überprüfung kann die der Dienst DynamoDB in der Webkonsole geöffnet werden.
Sind in der Tabelle Daten hinterlegt, war der Prozess erfolgreich.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{50-Implementierung/DynamoWeb.png}
    \caption{Verifizierung der Lambda-Funktion}
    \label{fig:meine-grafik}
\end{figure}

Die folgende Grafik zeigt den Erfolg der Lambda-Funktion.
In der Grafik ist nur ein kleiner Ausschnitt der gespeicherten Accounts zu sehen.
Als ID wurde eine MD5 Hash aus dem Accountnamen und der AccountID gewält, um die Eindeutigkeit sicherzustellen.
Es kann nicht ausgeschlossen werden, dass ein anderer Wert eventuell erneut auftritt.
Der Hash-Wert wird in Lambda mit dem Modul \verb+crypto+ realisiert.

\subsection{Implementierung Authentifizierung}

Im Abschnitt \ref{CognitoEntscheidung} \nameref{CognitoEntscheidung} wurde bereits erwähnt, dass Amplify in Kombination mit Cognito
alle benötigten Module für eine vollständige Authentifizierung beinhaltet.
Um eine Authentifizierung für Amplify hinzuzufügen muss der Befehl \verb+amplify add auth+ ausgeführt werden.

\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lavender} ]
  Do you want to use the default authentication and security configuration? Default configuration
  How do you want users to be able to sign in? E-Mail
  Do you want to configure advanced settings?  No, I am done.
\end{lstlisting}

Nach dem Befehl \verb+amplify push+ wird ein Cognito User Pool inklusive App Clients erstellt.
Über die Webkonsole besteht im Anschluss Option die Option MFA zu aktivieren.

Für die Einbindung in das React Frontend bietet das Amplify-Framework ein fertige Komponente an.
Die Komponente \verb+withAuthenticator+ muss in dem Frontend importiert werden und die Hauptkomponente exportieren.\cite[]{ImpAuth}
Der Auszug aus dem Code(\verb+index.js+):


\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lavender} ]
    import { withAuthenticator, AmplifySignOut } from "@aws-amplify/ui-react";

    class AWSAccountListsMaterial extends React.Component {
        [...]
    }
    export default withAuthenticator(AWSAccountListsMaterial, true)
    \end{lstlisting}

Die React Komponente \verb+AWSAccountListsMaterial+ beinhaltet den Code zum Abfragen der Daten aus der DynamoDB-Tabelle und zum Erstellen der Übersicht.
Diese Komponente wird mit \verb+withAuthenticator+ umhüllt und exportiert.

Startet man den Server im Anschluss erneut und ruft die Anwendung auf, erscheint eine voll funktionsfähige Login-Maske.
Diese Ansicht lässt sich auf Wunsch noch anpassen.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{50-Implementierung/Login.png}
    \caption{Login-Maske mit Amplify und Cognito}
    \label{fig:meine-grafik}
\end{figure}

Ohne Cognito und Amplify wäre Implementierung einer sicheren und funktionierenden Authentifizierungsmethode einer der aufwändigeren Aufgaben.
Dank der vorgefertigten Module ist es mit Amplify jedoch schnell umsetzbar.



\subsubsection{Probleme mit AzureAD}

Wie im Abschnitt \ref{Authentifizierung} \nameref{Authentifizierung} bereits erwähnt, wäre es wünschenswert die Anmeldung mit Unternehmensidentitäten zu ermöglichen.
Die Mediengruppe RTL nutzt hierfür den Dienst Azure Active Directory.
Mittlerweile sind einige Anbindung als SSO über Azure AD verfügbar.
Die Anmeldung zu allen drei Cloud Providern erfolgt etwa über die gemeinsame Identität des Unternehmens.

Cognito bietet eine Unterstützung mit Unternehmens-Identitätsanbietern über SAML an.
Dafür müssen Konfigurationen innerhalb von Azure und von AWS Cognito getätigt werden.
Während des Vorgangs ist zur Erkenntnis gekommen, dass es keine geeignete Implementierung in Zusammenspiel mit Amplify gibt.
Während des Versuchs wurden mehrere Anleitungen im Internet ausprobiert.
Der Cognito Dienst wurde dabei mit einer \glqq Azure Enterprise Application\grqq{} konfiguriert und verknüpft.
Bei \glqq Azure Enterprise Application\grqq{} handelt es sich um einen Dienst der zur Verwaltung von Identitäten genutzt wird.
Nach der Einrichtung sind leider weiterhin Fehlermeldungen aufgetreten.
Das Ergebnis einer Recherche zeigte, dass Amplify für diese spezielle Anbindung nicht optimiert ist.
Der SSO Authentifizierungsweg muss in das Frontend eingebaut werden.
Für diesen Prozess existieren im Internet mehrere Dokumentationen für Android oder iOS Apps.
Für React oder ein anderes JavaScript-Framework scheint die Integration deutlich komplexer.
Auf der Website \verb+https://dunlop.geek.nz/aws-cognito-azure-ad-react-amplify/+ wird ein Lösungsvorschlag angeboten, der jedoch im Rahmen dieser Bachelorarbeit nicht umgesetzt wird.
Laut der Anleitung ist es notwendig mehrere Stellen im Frontend stark zu bearbeiten und einen großen Teil der Authentifizierung manuell zu erstellen.
Zudem ist es laut Autor notwendig die Datei \verb+aws-exports.js+ zu bearbeiten, wobei in der Datei selbst eine Warnung zu finden ist dies nicht zu tun.
Auszug aws-exports.js:
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lightgray} ]
    // WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten.
    \end{lstlisting}

Aufgrund des hohen Aufwands und der nicht zufriedenstellenden Lösung wird die Anwendung vorerst ohne eine Anbindung an Untermehmensaccounts auskommen.
Mitarbeiter die Zugang benötigten müssen sich einen separaten Account erstellen.
Falls in Zukunft eine bessere Option zur Verfügung steht, kann sie jederzeit hinzugefügt werden, ohne das bestehende System zu beeinträchtigen.


\subsection{Implementierung Frontend und Hosting}

\subsubsection{Programmierung React Frontend}
\label{ReactFrontend}
Im letzten Schritt der Implementierung muss das Frontend konfiguriert werden und die gesamte Anwendung veröffentlicht werden.
Bisher weißt das Frontend eine Authentifizierung auf und dank der Lambda-Funktion sind Informationen in der DynamoDB-Tabelle verfügbar.
Nun muss mit React und AppSync eine Abfrage der Daten stattfinden.
Am Anschluss müssen die Daten visualisiert werden.
Um erste Erfahrungen mit React zu sammeln, wurde eine Komponente zur Begrüßung erstellt.
Die React Komponente \verb+Greeting+ gibt zwei simple HTML Elemente mit einem definierten Text zurück.
Als nächstes wurde die React Komponente \verb+AWSAccountLists+ erzeugt, die zur Aufgabe auf die DynamoDB-Tabelle zuzugreifen.
Zuerst wird eine passende Query benötigt, die alle Daten abfragt.
\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lavender} ]
    // GraphQL Query to get all data
    const listAllAccounts = `query listAllAccounts {
      listAccounts (limit: 300) {
        items{
          id
          accountid
          num
          name
          email
          status
        }
      }
    }`;
    \end{lstlisting}



Auch hier muss sichergestellt werden, dass zuerst alle Daten bereits abgerufen sind bevor sie verwendet werden.
React bietet dazu die Funktion \verb+componentDidMount()+ an, die exakt für diesen Anwendungsfall existiert. \cite[]{ReactComp}
Innerhalb der Funktion \verb+componentDidMount()+ wird die Funktion \verb+queryAccounts()+ gestartet.
Hier wird der Befehl \verb+API.graphql(graphqlOperation(listAllAccounts))+ ausgeführt, der von GraphQL zur Verfügung gestellt wird. \cite[]{AmplifyAPI}
Dieser Befehl führt die zuvor angegebene Query aus.
Gespeichert werden die Daten in der State Variable.
State kann alle internen Daten einer Komponente beinhalten.
Wird die State Variable mithilfe von \verb+setState()+ geändert, ruft React automatisch die Renderfunktion erneut auf und aktualisiert die Seite.
In einer reinen JavaScript basierten Anwendung wäre diese Implementation aufwändiger.
Im letzten Schritt müssen die Information aus der State Variable im Frontend angezeigt werden.
Hierfür eignet sich eine tabellarische Ansicht am meisten.
Zuerst wurde mit JSX ein HTML \verb+<table>+ Element erstellt und die einzelnen Daten korrekt hinzugefügt.
Da hierbei jedoch jede weitere Funktionalität manuell entwickelt werden muss, wurde letztendlich die frei zugängliche Komponente \glqq material-table\grqq{} genutzt.
Diese Komponente ermöglicht das Erstellen einer übersichtlichen Tabellen mit den wichtigsten Features wie einer Suche oder einer Sortierfunktion.
Zudem ist nahezu jeder Aspekt frei konfigurierbar, etwa die Anzahl an Elementen pro Seite.
 Das folgende Bild zeigt das Ergebnis nach der Implementierung des Codes:
\clearpage
 \begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{50-Implementierung/Webanwendung.png}
    \caption{Konfigurierte Website mit zugehörigen Daten}
    \label{fig:meine-grafik}
\end{figure}

\subsubsection{Hosting}

Da alle Komponenten erfolgreich implementiert worden sind und die Webanwendung alle geforderten Aufgaben erfüllt, kann sie veröffentlicht werden.
Mithilfe von \verb+amplify add hosting+ kann die Webanwendung bei Amazon gehosted werden.
In diesem Schritt kann Amplify zudem eine Integration mit GitHub übernehmen.
Es wird ein bestimmtes Repository mit Amplify verknüpft.
Sobald neuer Code in das Repository hochgeladen wird, startet Amplify ein automatisches Deployment mit diesen Änderungen.
Werden mehrere Branches mit unterschiedlichen Umgebungen genutzt, etwa Dev und Prod, können diese ebenfalls seperat hinzugefügt werden.
Nach Fertigstellung, gibt Amplify eine URL zurück über die die Anwendung aufgerufen werden kann.
Auf Wunsch kann hier im weiteren Verlauf eine eigene Domäne hinzugefügt werden.

\begin{lstlisting}[basicstyle=\ttfamily\small, breaklines=true , frame = single, backgroundcolor=\color{lavender} ]
    [143302S0:node-tst] master # amplify add hosting
    Select the plugin module to execute Hosting with Amplify Console (Managed hosting with custom domains, Continuous deployment)
    Choose a type Continuous deployment (Git-based deployments)
    Continuous deployment is configured in the Amplify Console. Please hit enter once you connect your repository
    [...]
    Amplify hosting urls:
    FrontEnd Env   Domain
    dev            https://dev.drjgagjbys8gs.amplifyapp.com

    \end{lstlisting}

